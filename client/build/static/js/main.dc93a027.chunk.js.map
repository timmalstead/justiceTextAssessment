{"version":3,"sources":["globalStyle.js","reducerAndTypes.js","hooks/useFetch.js","hooks/useLazyLoad.js","hooks/useVisibleParagraphs.js","components/Search/style.js","components/Search/index.js","components/TextItem/style.js","components/TextItem/index.js","components/Paragraph/style.js","components/Paragraph/index.js","App.js","index.js"],"names":["GlobalStyle","createGlobalStyle","AppContainer","styled","div","displayName","Loader","fetchReducer","state","action","type","paragraphs","concat","fetching","useFetch","dispatch","counter","useState","isFirstCall","setIsFirstCall","savedListOfPromises","setSavedListOfPromises","useEffect","a","fetch","response","json","list","listOfPromises","map","id","then","data","Promise","all","slice","length","fetchData","useLazyLoad","scrollRef","setCounter","scrollObserver","useCallback","node","IntersectionObserver","entries","forEach","element","isIntersecting","prevNum","observe","current","useVisibleParagraphs","nodeListIdent","paragraphData","setVisibleParagraphs","paragraphsRef","useRef","paragraphObserver","entry","paragraphId","target","prevState","Set","filter","document","querySelectorAll","SearchHolder","Input","input","Search","searchInput","setSearchInput","placeholder","value","onChange","Text","span","highlight","memo","visible","info","start","contentEditable","suppressContentEditableWarning","text","Article","p","Paragraph","i","row","visibleParagraphs","idRef","v4","includes","className","textitem","j","search","key","App","useReducer","paragraphDispatch","setValue","paragraphCounter","setParagraphCounter","bottomBoundaryRef","setInterval","Math","floor","random","ref","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.dc93a027.chunk.js","sourcesContent":["import styled, { createGlobalStyle } from \"styled-components\"\n\n// GlobalStyle Styled Component to enforce CSS rules app wid\n// I chose to make this a fixed width app to keep it very clean and basic, with the focus on the content and a UI that would get out of the user's way and allow them to do the editing they need to do.\nconst GlobalStyle = createGlobalStyle`\n    * {\n        margin: 0;\n        padding: 0;\n    }\n\n    body {\n        width: 1400px;\n        height:100%;\n        margin: auto;\n        font-family: \"Lato\", Arial, Helvetica, sans-serif;\n        background-color: #EEEEEE66;\n    }\n`\nexport default GlobalStyle\n\nexport const AppContainer = styled.div`\n  text-align: center;\n`\n\nAppContainer.displayName = \"AppContainer\"\n\n// When viewport intersects with below component, a new call to the backend is made. Because we have made this 1000px high, this will occur well before the user reaches the end of the page. This allows the user uninterrupted scrolling, without the need to call all the data in the api upon first loading the app.\n\nexport const Loader = styled.div`\n  height: 1000px;\n  visibility: hidden;\n`\nLoader.displayName = \"Loader\"\n","// Strings assigned to constant variables that will be used as reducer objects in the useFetch hook\nexport const STACK_PARAGRAPHS = \"STACK_PARAGRAPHS\"\n\nexport const FETCHING_PARAGRAPHS = \"FETCHING_PARAGRAPHS\"\n\n// Reducer used in useFetch hook to interact with fetch api. Returns state regarding current stage of fetching process and paragraphs fetched from api and held in state\nexport const fetchReducer = (state, action) => {\n  switch (action.type) {\n    case STACK_PARAGRAPHS:\n      return {\n        ...state,\n        paragraphs: state.paragraphs.concat(action.paragraphs),\n      }\n    case FETCHING_PARAGRAPHS:\n      return { ...state, fetching: action.fetching }\n    default:\n      return state\n  }\n}\n","import { useEffect, useState } from \"react\"\nimport { STACK_PARAGRAPHS, FETCHING_PARAGRAPHS } from \"../reducerAndTypes\"\n\n// hook that accepts two arguments\n//  1) A dispatch function used to send objects and data back to the reducer managing the state of fetched data\n//  2) A counter managed by the useLazyLoad hook to inform this hook which paragraphs to fetch\nconst useFetch = (dispatch, counter) => {\n  // a boolean used to differentiate between the initial api call and all call afterwards\n  const [isFirstCall, setIsFirstCall] = useState(true)\n  // an array that will be used to call fetch promises before they are called\n  const [savedListOfPromises, setSavedListOfPromises] = useState([])\n  useEffect(() => {\n    //data fetching function to be called each time a property in the useEffect dependency array is changed\n    const fetchData = async () => {\n      try {\n        //sets fetching paragraphs boolean in reducer to true\n        dispatch({ type: FETCHING_PARAGRAPHS, fetching: true })\n        //if isFirstCall is true. i.e. if app is loading\n        if (isFirstCall) {\n          //sets isFirstCall to false so this block of code will only execute on the first call\n          setIsFirstCall(false)\n          // executes initial call to api to fetch list of data to be called in subsequent requests. With all requests to the api, I chose to fill in the full url despite their being a proxy already set up. I did this so the backend can serve a dev or served mock production environment.\n          const response = await fetch(`http://localhost:8080/api/dataIdList`)\n          //parses above promise object into JSON\n          const list = await response.json()\n          //changes each id in the fetched list to an unfulfilled promise that may be called later\n          const listOfPromises = list.map((id) =>\n            // promise object containing a fetch call for one id that will be turned into JSON upon reciept\n            fetch(`http://localhost:8080/api/dataItem/${id}`).then((data) =>\n              data.json()\n            )\n          )\n          // sets above list of promises into local state\n          setSavedListOfPromises(listOfPromises)\n          // calls list of first paragraphs to return.\n          // Note that it does not call these from state, but rather from the variable we inserted into state. This is done this way purposefully, as the state setting function operates asynchronously and we cannot be certain it will have completed by the time the following expression begins execution\n          const paragraphs = await Promise.all(\n            listOfPromises.slice(0, counter + 1)\n          )\n          // sends returned data back to reducers. Because we constructed the promises to resolve to JSON, we do not need to do it here\n          dispatch({ type: STACK_PARAGRAPHS, paragraphs })\n          //if isFirstCall is false\n        } else {\n          if (savedListOfPromises.length) {\n            // calls two additional promises based on the current value of the counter. this is triggered by the bottom ref intersecting with the browser's viewport\n            const paragraphs = await Promise.all(\n              savedListOfPromises.slice(counter - 1, counter + 1)\n            )\n            // returns fetched data to reducer\n            dispatch({ type: STACK_PARAGRAPHS, paragraphs })\n          }\n        }\n        // sets fetch indicator in reducer to false\n        dispatch({ type: FETCHING_PARAGRAPHS, fetching: false })\n      } catch (err) {\n        //if an error is thrown at any point in the try block, the dispatch will set to false and the error will be returned\n        dispatch({ type: FETCHING_PARAGRAPHS, fetching: false })\n        return err\n      }\n    }\n    //calls above async function each time anything in the below array changes\n    fetchData()\n  }, [\n    dispatch,\n    counter,\n    isFirstCall,\n    setIsFirstCall,\n    savedListOfPromises,\n    setSavedListOfPromises,\n  ])\n}\n\nexport default useFetch\n","import { useEffect, useCallback } from \"react\"\n\n// hook that accepts two arguments:\n//  1) a ref to attach an IntersectionObserver to\n//  2) a state setting function used to increase the pagination counter\nconst useLazyLoad = (scrollRef, setCounter) => {\n  // IntersectionObserver browser api attached to be attached to a ref. IntersectionObserver is a browser API used to attach callbacks to DOM nodes, or in our case refs to DOM nodes, that fire whenever a condition is met regarding viewport intersection. Here I will be using it to increase the counter whenever the ref intersects with the viewport\n  const scrollObserver = useCallback(\n    (node) =>\n      //attaching a callback to be fired upon viewport intersection\n      new IntersectionObserver(\n        (entries) =>\n          entries.forEach((element) => {\n            // isIntersecting is a boolean on each IntersectionObserver\n            if (element.isIntersecting) {\n              // if isIntersecting evaluates to true, fire a callback adding 2 to the pagination counter\n              setCounter((prevNum) => (prevNum += 2))\n            }\n          })\n        //adds node to list of elements being watch by IntersectionObserver\n      ).observe(node),\n    [setCounter]\n  )\n\n  // useEffect hook used to apply the IntersectionObserver object to supplied ref\n  useEffect(() => {\n    if (scrollRef.current) {\n      //if the ref has a .current property, and is thus ready, attach the intersection observer to the ref\n      scrollObserver(scrollRef.current)\n    }\n  }, [scrollObserver, scrollRef])\n}\n\nexport default useLazyLoad\n","import { useEffect, useCallback, useRef } from \"react\"\n\n// hook that accepts three arguments:\n//  1) a CSS selector to target a nodeList to attach refs to\n//  2) paragraph data fetched from Express API\n//  3) a state setting function used to set each paragraph into state, thus rendering, or filter it out of state, thus making it not render.\nconst useVisibleParagraphs = (\n  nodeListIdent,\n  paragraphData,\n  setVisibleParagraphs\n) => {\n  // ref that will later be used to attach to node list\n  const paragraphsRef = useRef(null)\n\n  // IntersectionObserver browser api attached to be attached to refs. IntersectionObserver is a browser API used to attach callbacks to DOM nodes, or in our case refs to DOM nodes, that fire whenever a condition is met regarding viewport intersection. Simply put, I will be using it to fire a callback to add a paragraph to a list of paragraphs that are allowed to render and run the expensive highlighting calculation when they are on screen. This will help make the rendering and highlighting run much more efficently, sometimes seeming almost instant.\n  // Because we are wrapping this in a useCallback hook, it will know to not to run on every render but only when anything in its dependency array changes\n  const paragraphObserver = useCallback(\n    (node) => {\n      const intObs = new IntersectionObserver((entries) =>\n        //attaching a callback to be fired upon viewport intersection\n        entries.forEach((entry) => {\n          const paragraphId = entry.target.id\n          // isIntersecting is a boolean on each IntersectionObserver\n          if (entry.isIntersecting)\n            // if isIntersecting evaluates to true, fire a callback adding the visible paragraph to the visibleParagraph array\n            // I change it to a Set and back again to prevent my array being filled up with multiple instances of the same id\n            setVisibleParagraphs((prevState) => [\n              ...new Set([...prevState, paragraphId]),\n            ])\n          // if isIntersecting evaluates to false, fire a callback returning a copy of the previous state with the id filtered out\n          else\n            setVisibleParagraphs((prevState) =>\n              prevState.filter((id) => id !== paragraphId)\n            )\n        })\n      )\n      //adds node to list of elements being watch by IntersectionObserver\n      intObs.observe(node)\n    },\n    [setVisibleParagraphs]\n  )\n\n  // useEffect hook used to apply the IntersectionObserver object we have created to each node in a nodeList\n  useEffect(() => {\n    // query selector used to find each instance of the identifier we have supplied, in this case .full-paragraph\n    paragraphsRef.current = document.querySelectorAll(nodeListIdent)\n    //if the ref has a .current property, and is thus ready, attach the intersection observer to the ref\n    if (paragraphsRef.current) {\n      paragraphsRef.current.forEach((node) => paragraphObserver(node))\n    }\n  }, [\n    paragraphObserver,\n    paragraphsRef,\n    paragraphData.paragraphs,\n    nodeListIdent,\n  ])\n}\n\nexport default useVisibleParagraphs\n","import styled from \"styled-components\"\n\n//holder for search bar and title, \"pinned\" to upper left of viewport\nexport const SearchHolder = styled.div`\n  background-color: #6320ee;\n  width: 10.5em;\n  padding: 0.5em 1em;\n  position: fixed;\n  left: 0;\n  top: 0;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  border-radius: 0 0 3em 0;\n  color: white;\n  > * {\n    margin: 0 0 0.5em 0;\n  }\n`\n\nSearchHolder.displayName = \"SearchHolder\"\n\n//style for input component, including styling for :focus state and ::placeholder pseudo element\nexport const Input = styled.input`\n  width: 10em;\n  border-radius: 0.5em;\n  padding: 0.5em;\n  outline: none;\n  border: none;\n  transition: transform 0.25s linear;\n  color: #6320ee;\n\n  :focus {\n    transform: scale(1.1);\n  }\n\n  ::placeholder {\n    color: #6320ee;\n  }\n`\n\nInput.displayName = \"Input\"\n","//static imports\nimport React from \"react\"\n//style imports from styled-components\nimport { SearchHolder, Input } from \"./style\"\n\n//functional component for title and search bar\nconst Search = ({ searchInput, setSearchInput }) => {\n  //function to lift user input to App component\n  const handleChange = ({ target }) => setSearchInput(target.value)\n\n  return (\n    <SearchHolder>\n      <h2>JT Online Book</h2>\n      <Input\n        //props denoting type of input, placeholder pseudo element, controlled value and onChange synthetic event\n        type=\"text\"\n        placeholder=\"Search Text\"\n        value={searchInput}\n        onChange={handleChange}\n      />\n    </SearchHolder>\n  )\n}\n\nexport default Search\n","import styled from \"styled-components\"\n\n//styled span component with text and background color set to change depending of highlight prop\nconst Text = styled.span`\n  background-color: ${({ highlight }) => (highlight ? \"#fdbcd4\" : null)};\n  color: ${({ highlight }) => (highlight ? \"black\" : \"#777\")};\n`\n\nText.displayName = \"Text\"\n\nexport default Text\n","//static imports\n//importing react and React.memo higher order component\nimport React, { memo } from \"react\"\nimport Text from \"./style\"\n\n//Text functional component\nconst TextItem = ({ data, value, visible }) => (\n  <Text\n    // If visible prop is true, executes calculation function\n    // I changed the calculation function from using Math.floor() to a bitwise OR operator. This provides the same functionality but with a marked performance boost\n    // If visible prop is true and calculation evalutes to true, the prop will send infor the Text styled component to change the background and text colors of component\n    highlight={visible ? ((data.info.start / 2000) | 0) % value === 0 : null}\n    // Allows user to edit content. Note that edits are only on the client side, and will not be persitent\n    contentEditable\n    suppressContentEditableWarning\n  >\n    {`${data.text} `}\n  </Text>\n)\n\n// Exports component wrapped in react memoization function. This allows us save data and avoid rerenders if exact combinations of props are reused. As the value can only resolve to ten values, this will save us quite a bit performance wise\nexport default memo(TextItem)\n","import styled from \"styled-components\"\n\n//CSS styling for fetched paragraph elements. To lessen amount of calculations needed, I supplied a fixed height in pixels. Styling info also includes infor for :hover, :focus and :focus-within states\nconst Article = styled.p`\n  width: 65%;\n  margin: 0.5em auto;\n  overflow-wrap: break-word;\n  height: 370px;\n  font-family: Georgia, Times, serif;\n  font-size: 15px;\n  font-weight: 300;\n  box-sizing: border-box;\n  padding: 0.6em 0.55em 0 0.55em;\n  box-shadow: 0 0 0.25em #6320ee88;\n  border-radius: 1em;\n  transition: transform 0.15s linear;\n  background-color: white;\n\n  :hover,\n  :focus,\n  :focus-within {\n    transform: scale(1.02);\n  }\n`\n\nArticle.displayName = \"Article\"\n\nexport default Article\n","// static imports\n// React import, including ref import\nimport React, { useRef } from \"react\"\n// styled-components imports\nimport TextItem from \"../TextItem\"\nimport Article from \"./style\"\n// imprt of v4 algorithm from uuid, which will be used to make my unique identifiers to denote visible elements\nimport { v4 } from \"uuid\"\n\n// paragraph functional component, with number data from map function in App.js, row from fetched data, interval generated value, searchInput and list of visible paragraphs elements all passed down\nconst Paragraph = ({ i, row, value, searchInput, visibleParagraphs }) => {\n  // ref created with fresh unique identifier attached to .current property\n  const idRef = useRef(v4()).current\n\n  // boolean indicating whether visibleParagraphs array includes the unique id\n  const visible = visibleParagraphs.includes(idRef) ? true : false\n\n  // Created Article component containing a map of data generated from row prop\n  return (\n    <Article className={\"full-paragraph\"} id={idRef}>\n      {row.length\n        ? // if row prop contains data, a TextItem component will be created from each piece of data.\n          // if searchInput is present, the TextItem component that contains that same data will be rendered and will not be if no data matches\n          row.map((textitem, j) => {\n            if (\n              searchInput.length > 0 &&\n              textitem.text.search(searchInput) === -1\n            ) {\n              return null\n            }\n            return (\n              <TextItem\n                //props passed down to TextItem component including fetched value and data, and visible boolean data created above\n                key={`${i}${j}`}\n                value={value}\n                data={textitem}\n                visible={visible}\n              />\n            )\n          })\n        : null}\n    </Article>\n  )\n}\n\nexport default Paragraph\n","// Static imports. This app is small enough that I didn't see an advantage to be gained by introducing dynamic imports and enforcing code splitting\n// React Imports\nimport React, { useEffect, useState, useReducer, useRef } from \"react\"\n// custom hook imports\nimport { useFetch, useLazyLoad, useVisibleParagraphs } from \"./hooks\"\n// reducer and type file import\nimport { fetchReducer } from \"./reducerAndTypes\"\n// local styled component imports\nimport { AppContainer, Loader } from \"./globalStyle\"\n// functional component imports\nimport Search from \"./components/Search\"\nimport Paragraph from \"./components/Paragraph\"\n\nconst INTERVAL_TIME = 2000\n\nconst App = () => {\n  // useReducer hook used to manage the state both the fetch api and the data returned from it\n  const [paragraphData, paragraphDispatch] = useReducer(fetchReducer, {\n    paragraphs: [],\n    fetching: true,\n  })\n  // value returned from Math.random function in setInterval->setValue function below\n  const [value, setValue] = useState(0)\n  // state to manage search bar\n  const [searchInput, setSearchInput] = useState(\"\")\n  // state used to count what paragraphs have been called by useFetch and which are still to be balled\n  const [paragraphCounter, setParagraphCounter] = useState(1)\n  // state used to keep track of which paragraphs are intersecting with the viewport, and are thus visible to the user\n  const [visibleParagraphs, setVisibleParagraphs] = useState([])\n  // ref to attach to bottom of page, used to call a fetch function from useFetch when ref intersects with viewport, called paging\n  const bottomBoundaryRef = useRef(null)\n\n  /** DO NOT CHANGE THE FUNCTION BELOW */\n  useEffect(() => {\n    setInterval(() => {\n      // Find random bucket of words to highlight\n      setValue(Math.floor(Math.random() * 10))\n    }, INTERVAL_TIME)\n  }, [])\n  /** DO NOT CHANGE THE FUNCTION ABOVE */\n\n  // custom hook managing calls to the express api\n  useFetch(paragraphDispatch, paragraphCounter)\n  // custom hook managing ref that manages paging and\n  useLazyLoad(bottomBoundaryRef, setParagraphCounter)\n  // custom hook managing which paragraphs to render\n  useVisibleParagraphs(\".full-paragraph\", paragraphData, setVisibleParagraphs)\n\n  return (\n    <AppContainer>\n      {/* search functional component */}\n      <Search searchInput={searchInput} setSearchInput={setSearchInput} />\n      <div>\n        {/* Map of paragraphData fetched using useFetch. A paragraph component is constructed for each piece of data returned.*/}\n        {paragraphData.paragraphs.length\n          ? paragraphData.paragraphs.map((row, i) => (\n              <Paragraph\n                key={`p${i}`}\n                i={i}\n                row={row}\n                value={value}\n                searchInput={searchInput}\n                visibleParagraphs={visibleParagraphs}\n              />\n            ))\n          : null}\n      </div>\n      {/* When viewport intersects with below component, a new call to the backend is made. This allows the user uninterrupted scrolling, without the need to call all the data in the api upon first loading the app.*/}\n      <Loader ref={bottomBoundaryRef} />\n    </AppContainer>\n  )\n}\n\nexport default App\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport GlobalStyle from \"./globalStyle\"\nimport App from \"./App\"\n\n// ReactDOM implementation of React on \"#root\" node of DOM. I chose to include the Styled Components <GlobalStyle /> component here as it targets CSS selectors \"above\" the React app and this level makes the most sense to me semantically\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n    {/* GlobalStyle Styled Component to enforce CSS rules app wide */}\n    <GlobalStyle />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}